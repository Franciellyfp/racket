; ordena: lista-de-números -> lista-de-números
; exemplos:
; (ordena empty) -> produz empty
; (ordena (list 12 20 -5)) -> produz (list 20 12 -5)

(define (ordena ldn)
; se ldn for vazia: retornar lista vazia
; se ldn não for vazia, deve inserir o primeiro elemento de ldn na posição correta do resto da lista ordenado
(cond
  [(empty? ldn) empty]
  [else (insere (first ldn) (ordena (rest ldn)))]))

; insere: número lista-de-números -> lista-de-números
; exemplos:
; (insere -5 empty) -> produz (list -5)
; (insere 12 (list 20 -5)) -> produz (list 20 12 -5)

(define (insere n ldn)
; se ldn for vazia, devolver uma lista com n
; se n é maior que o primeiro elemento ldn, deve-se contruir uma lista com n e ldn
; caso contrário deve-se contruir uma lista com o primeiro elemento de ldn e a lista com o n inserido na posição correta do resto de ldn
  (cond
    [(empty? ldn)(list n)]
    [(> n (first ldn)) (cons n ldn)]
    [else (cons (first ldn) (insere n (rest ldn)))]))

; exemplos:
; (ordena (list 12 20 -5))

(define (descendente-olhos-azuis? genitor)
; verificar se genitor tem olhos azuis, devolver true
; se algum descendente de genitor tem olhos azuis, devolver true
  (or
   (symbol=? (genitor-olhos genitor) 'azuis)
   (filho-olhos-azuis? (genitor-filhos genitor))))

; filhos-olhos-azuis? : lista-de-filhos -> booleano
(define(filho-olhos-azuis? lf)
  (cond
    ; se a lf for vazia, devolver false
    ; devolver se o primeiro da lf tem olhos azuis, ou se algum outro filho do resto da lf tem olhos azuis
    [(empty? lf) false]
    [else (or (descendente-olhos-azuis? (first lf)) (filho-olhos-azuis (rest lf)))]))

; filho-olhos-azuis: lista-de-filhos -> Número
(define(filho-olhos-azuis lf)
  (cond
    ; se a lf for vazia, devolver 0
    [(empty? lf) 0]
    ; devolver a soma do nº de descendente de olhos azuis do primeiro lf com o nº de descendentes de olhos azuis do resto da lf
    [else (+ (descendente-olhos-azuis(first lf)) (filhos-olhos-azuis(rest lf)))]))


